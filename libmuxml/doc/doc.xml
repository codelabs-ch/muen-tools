<doc name="Muen System Specification">
 <author>The Muen Team</author>
 <version>0.1</version>

 <latex_preamble>
  \usepackage{listings}
  \usepackage{pifont,mdframed}

  \definecolor{mygreen}{rgb}{0,0.6,0}
  \definecolor{mygray}{rgb}{0.5,0.5,0.5}
  \definecolor{mymauve}{rgb}{0.58,0,0.82}

  \lstset{
  backgroundcolor=\color{white},
  basicstyle=\footnotesize\ttfamily,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  commentstyle=\color{mygreen},
  extendedchars=true,
  rangeprefix=&lt;!--D\ @Lst\ ,
  rangesuffix=\ -->,
  includerangemarker=false,
  frame=single,
  keepspaces=true,
  keywordstyle=\color{blue},
  language=Octave,
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{mygray},
  rulecolor=\color{black},
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stepnumber=2,
  stringstyle=\color{mymauve},
  tabsize=2,
  title=\lstname
  }

  \newenvironment{warning}
  {\par\begin{mdframed}[linewidht=1pt,linecolor=red]
  \begin{list}{}{\leftmargin=1cm
  \labelwidth=\leftmargin}\item[\color{red}\Large\ding{43}]}
  {\end{list}\end{mdframed}\par}
 </latex_preamble>

 <xsd id="system_src.xsd" label="Policy Schema Documentation" priority="10" section="schema" file="generated/system_src.xsd" type="systemType" />

 <section id="introduction" label="Introduction" priority="0">
  <text priority="0">
   The Muen system policy is a description of a component-based system running
   on top of the Muen Separation Kernel. It defines what hardware resources are
   present, how many active components (called subjects) the system is composed
   of, how they interact and which system resources they are allowed to access.
   The contents a Muen system policy is composed of is outlined in section
   \ref{intro-policy-content} of this document.

   A system integrator specifies and configures such a component-based system at
   integration time in XML format. The Muen toolchain transforms the system
   description in multiple steps to the final system description, resolving
   abstractions which exist to make live simpler and less error-prone to the
   integrator. The various XML-formats involved in this process are described in
   section \ref{intro-policy-format}, an overview of the Muen toolchain is
   presented in section \ref{intro-integration}.

   The Muen Separation Kernel (SK) is a policy enforcer, in the sense that it
   has no knowledge about the actual content of the generated data structures.
   The most important and final step in the integration of a Muen system is
   therefore the actual generation of the data structures which guarantee
   subject isolation and the composition of the final system image. This step is
   performed by a trusted system composer called (static) $\tau$0.  This is
   explained in section \ref{tau0-concept}.

   Section \ref{schema} then specifies the XML-schema for the system source
   format of the Muen system policy. Explanations and examples illustrate how to
   configure a component-based system with the Muen SK.
  </text>

  <section id="intro-policy-content" label="Policy Content" priority="0">
   <text priority="0">
    The Muen policy specifies the following properties of a system:

    \begin{itemize}
    \item Configuration values
    \item Hardware resources
    \item Platform description
    \item Kernel diagnostics device
    \item Physical memory regions
    \item Device domains
    \item Events
    \item Communication channels
    \item Components
    \item Subjects
    \item Scheduling plans
    \end{itemize}

    The policy therefore serves as a static description of a Muen system. Since
    all aspects of the system are fixed at integration time the policy is very
    well suited for automated and manual validation prior to system execution.

    The details of each property is explained with examples in the XSD-schema of
    the format source policy in section \ref{schema}.
   </text>
  </section>

  <section id="intro-policy-format" label="Policy Format" priority="0">
   <text priority="0">
    The system policy is specified in XML. There are currently three different
    policy formats:

    \begin{itemize}
    \item Source Format
    \item Format A
    \item Format B
    \end{itemize}

    The motivation to have several policy formats is to provide abstractions and a
    compact way for users to specify a system while simultaneously facilitate
    reduced complexity of tools operating on the policy.

    The implementation of such tools is simplified by the absence of
    higher-level abstractions which would make the extraction of input data more
    involved. As an example, the tool responsible for page table generation can
    directly access all virtual memory mappings of a subject and must not
    concern itself with channels. The channel abstraction has already been
    broken down into the corresponding memory elements during the policy
    compilation step of the build process.

    The following sections give more detail about a specfic format.

    \pagebreak
    \begin{warning}
    Only the policy in format source is specified in this document, as the other
    formats are considered \emph{internal}. While it is possible to specify a
    system policy in format A or B, it is not recommended.
    \end{warning}
   </text>

   <section id="intro-policy-format-src" label="Source Format" priority="0">
    <text priority="0">
     The user-specified policy is written in the \emph{source format}.
     Constructs such as channels or events provide abstractions to simplify the
     specification of component-based systems. Many XML elements and attributes
     are optional and will be filled in with default values during later steps
     of the policy compilation process.

     Kernel and $\tau0$ resources are not part of the source format since they are also
     automatically added by the policy expansion step.

     Additionally the use of configuration values enables easy parametrization of
     the system policy.

     The policy in source format in specified in section \ref{schema}.
    </text>
   </section>

   <section id="intro-policy-format-a" label="Format A" priority="0">
    <text priority="0">
     Format A is a processed version of the source format where all includes are
     resolved and abstractions such as channels have been broken down into their
     underlying elements. For example, a channel is expanded to a physical
     memory region and the corresponding writer and reader subject mappings with
     the appropriate access rights.

     In this format all implicit elements, such as for example automatically
     generated page table memory regions, are specified. The kernel and $\tau$0
     configuration is also declared as part of format A.

     The only optional attributes are addresses of physical memory regions.
    </text>
   </section>

   <section id="intro-policy-format-b" label="Format B" priority="0">
    <text priority="0">
     Format B is equivalent to Format A except that all physical memory regions
     have a fixed location (i.e. their physical address is set).
    </text>
   </section>
  </section>

  <section id="intro-integration" label="System Integration" priority="0">
   <text priority="0">
    A Muen system specified via the system policy outlined in the previous
    sections and specified in section \ref{schema} is transformed and integrated
    by various tools to generate a bootable system image.

    The directed graph \ref{fig:integ} illustrates the process.

    \begin{figure}[hp]
    \centering
    \includegraphics[width=1\textwidth,height=0.96\textheight,keepaspectratio]{build_overview.eps}
    \caption{System Integration}
    \label{fig:integ}
    \end{figure}

    The top of the graph shows how configuration and build parameters are
    applied to the following constituents of the system policy:
    \begin{itemize}
    \item Hardware description (static)
    \item Hardware description (generated)
    \item Platform description
    \item System description
    \end{itemize}

    These inputs combined form the parameterized system policy in format source,
    which can be used by components to extract system information. Such
    information might be for example the log channel count of a debug server
    subject, or whether a specific debug facility has been enabled by the system
    integrator.

    The CSPECs mechanism outlined in the Muen Component Specification document
    \cite{muen:component_specification} can be used by components to generate
    source specifications (e.g.  in SPARK/Ada) from the component description.
    Furthermore, a component might expand its own component description with
    information extracted from system information. The expanded component
    description is then merged with the system policy for further processing.

    After all component descriptions have been merged into the system policy, it
    is expanded by the expander tool (see TODO). This step transforms the system
    policy from format source to format A. Abstractions like directed channels
    are now resolved to basic shared memory mechanisms and events.

    The allocater tool (see TODO) then loops over all physical memory regions
    which have no physical address assigned and allocates one from the usable
    pool. The usable pool information is extracted from the allocatable memory
    block list (\ref{system_src.xsd:memoryBlockType}) in the system policy.
    After that, the policy is transformed to format B.

    The policy is now checked for correctness by the validator tool (see TODO).
    If a misconfiguration is found, the user is informed and the build aborts. The checks
    performed by the validator tool are listed in section \ref{validation}. If
    no error is found, the system policy is now ready to be used for two things:

    \begin{itemize}
    \item Create a command stream for $\tau0$
    \item Generate kernel specifications (.ads)
    \end{itemize}

    The kernel source specifications contain tables and constants which are
    compiled into the kernel in the kernel build process. See the description of
    the \texttt{Skp} package hierarchy in the Muen Kernel Specification document
    \cite{muen:kernel_specification} for the exact information these packages
    provide.

    The command stream generator (ref:TODO) generates instructions in XML format
    for the $\tau0$ system composer explained in the following section.
   </text>

   <section id="tau0-concept" label="$\tau0$ Concept" priority="0">
    <text priority="0">
     The final system description created by the toolchain so far, as explained
     in the previous section, is again transformed to an XML command stream and
     fed together with other build artifacts to the trusted system composer
     $\tau0$.

     The $\tau0$ concept is a process within Muen development to gradually
     increase the dynamic of a component based system. The ultimate goal is to
     have a trusted $\tau0$ subject with extra privilege to interact with the
     Muen SK over the special $\tau0$ interface API. This would allow $\tau0$ to
     change system state at runtime.

     Since it must be guaranteed that a dynamic system is as secure as the
     static one, $\tau0$ must be developed with the same utter care as the
     kernel itself, meaning it must be written in SPARK/Ada and security
     properties which provide hard isolation must be formally proven.

     Two $\tau0$ scenarios are relevant:
     \begin{itemize}
     \item static
     \item dynamic
     \end{itemize}
    </text>

    <section id="tau0-static" label="Static" priority="0">
     <text priority="0">
      The static variant is the one which is currently implemented. $\tau0$ runs
      at integration time and assembles the system image by constructing the
      data structures guaranteeing isolation and merging in the build artifacts
      of the Muen toolchain.

      Static $\tau0$ fulfills its task by creating the system image in memory
      while processing the commands from the command stream. The following
      listing shows an example command stream: (TODO)

      $\tau0$ is written in SPARK/Ada and it applies memory typization to proof
      formal aspects of the system. Command processing starts from a well-known
      good state and it is enforced that each system state transition resulting
      from a new command input results in a good state again. If not, the
      command is rejected and the build aborts.

      See the project README or the webpage (TODO) for more information about
      the current state of the formal proofs and roadmap.
     </text>
    </section>

    <section id="tau0-dynamic" label="Dynamic" priority="0">
     <text priority="0">
      While the system image is composed by the static variant of $\tau0$, the
      goal is to run basically the same code as $\tau0$ subject at runtime. Note
      that this is not yet implemented but planned as a way forward to achieve
      more dynamic systems while having the same assurance about security and
      safety properties.

      The dynamic $\tau0$ running as subject would reconstruct the system state
      at integration time and continue to process commands from there. Commands
      might be sent to dynamic $\tau0$ by a special control subject, depending
      on the system use case.

      At runtime, memory can be initialized and additional subjects can be
      added.  All entities must conform to a policy which may limit the system
      to a set of preconfigured states.

      The dynamic variant can be divided into multiple sub-variants, depending
      on how dynamic system behavior is allowed. For example, the initial
      dynamic variant might only allow entity construction, not destruction.
     </text>
    </section>
   </section>

   <section id="tools" label="Toolchain" priority="0">
    <text priority="0">
     TODO: Merge in toolchain tools section.
    </text>
   </section>
  </section>

  <section id="validation" label="Policy Validation" priority="0">
   <text priority="0">
    As explained in section \ref{intro-integration}, the Muen system policy is
    transformed by various tools. Before a tool performs actions on the policy,
    it checks all required preconditions via \emph{validator} procedures. For
    example a tool accessing physical devices via subject logical device
    references will execute a validator checking such references for validity.

    Before the policy is used to generate system structures like page tables and
    the final system image, the allocated and expanded policy is again validated
    by executing a comprehensive set of checks. This is done by the
    \texttt{mucfgvalidate} tool.

    The following sections list the various checks executed by
    \texttt{mucfgvalidate} and the other Muen build tools in the toolchain.
   </text>
  </section>
 </section>

 <section id="schema" label="Schema" priority="0"/>

 <section id="appendix" label="Appendix" priority="1000">
  <section id="appendix-ap" label="Annotated Example Policy" priority="0">
   <text priority="0">
    \lstinputlisting[caption=Demo System (VT-d),label={lst:annotated-policy},language=XML,escapeinside={(*}{*)}]{annotated_policy.xml}
   </text>
  </section>
 </section>

</doc>
