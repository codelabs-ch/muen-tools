<?xml version="1.0"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"><xs:complexType name="booleanConfigValueType">
  <xs:annotation>
   <xs:documentation>
    Configuration option for values in boolean format.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType">
   <xs:annotation>
    <xs:documentation>
     Name of the configuration option.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="value" type="booleanType">
   <xs:annotation>
    <xs:documentation>
     Value of the configuration option.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="integerConfigValueType">
  <xs:annotation>
   <xs:documentation>
    Configuration option for values in integer format.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType">
   <xs:annotation>
    <xs:documentation>
     Name of the configuration option.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="value" type="xs:integer">
   <xs:annotation>
    <xs:documentation>
     Value of the configuration option.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="stringConfigValueType">
  <xs:annotation>
   <xs:documentation>
    Configuration option for values in string format.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType">
   <xs:annotation>
    <xs:documentation>
     Name of the configuration option.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="value" type="xs:string">
   <xs:annotation>
    <xs:documentation>
     Value of the configuration option.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="configType">
  <xs:annotation>
   <xs:documentation>
    The purpose of a config section is to specify configuration values which
    parameterize a system or a component. It allows to declare boolean, string
    and integer values. The following sections in the system policy provide
    support for configuration values:

    \begin{itemize}
    \item System
    \item Platform
    \item Component
    \end{itemize}

    During the build process, configuration values provided by the platform are
    merged into the global system configuration. Component configuration values
    allow the parameterization of component-local functionality.

    Besides component parameterization, configuration options can be used in
    \texttt{if} conditionals, as shown in the following example.


    \begin{lstlisting}[language=XML]
    &lt;if variable="xhcidbg_enabled" value="true"&gt;
     ...
    &lt;/if&gt;
    \end{lstlisting}


    If the type of the referenced variable is 'string' the comparison is case-sensitive.
    A second use case is XML attribute value expansion as follows:


    \begin{lstlisting}[language=XML]
    &lt;channel name="debuglog" size="$logchannel_size"/&gt;
    \end{lstlisting}


    The \texttt{size} attribute value is not specified directly, but parameterized via
    an integer configuration option.

    See line \ref{lst:af-lineref-config-global} in listing
    \ref{lst:annotated-policy} for an example config section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="boolean" type="booleanConfigValueType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="integer" type="integerConfigValueType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="string" type="stringConfigValueType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:simpleType name="vectorType">
  <xs:annotation>
   <xs:documentation>
    Vector number.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:nonNegativeInteger">
   <xs:maxInclusive value="255"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="irqNumberType">
  <xs:annotation>
   <xs:documentation>
    IRQ number. High IRQs are reserved for kernel usage.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:nonNegativeInteger">
   <xs:maxInclusive value="220"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="ioPortType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{ioPort} element specifies a device I/O port resource from
    \texttt{start} octet up to and including \texttt{end} octet. A single
    byte-accessed port is designated by specifying the same \texttt{start} and
    \texttt{end} values.

    See line \ref{lst:af-lineref-device-ioport} in listing
    \ref{lst:annotated-policy} for an example device IRQ declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of I/O port resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="start" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Start port of this resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="end" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     End port of this resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="irqType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{irq} element specifies a device IRQ resource.

    The specified IRQ number is one of:
    \begin{itemize}
    \item Legacy IRQ (ISA)~\\
    Range \texttt{0 .. 15}.
    \item PCI INTx IRQ, line-signaled~\\
    Range \texttt{0 .. Max\_LSI\_IRQ}, whereas \texttt{Max\_LSI\_IRQ} is defined
    by the hardware I/O APIC configuration \texttt{gsi\_base} +
    \texttt{max\_redirection\_entry} of I/O APIC with \texttt{max(gsi\_base)}.
    \texttt{gsi\_base} and \texttt{max\_redirection\_entry} are I/O APIC device
    capabilities.
    \end{itemize}

    \texttt{msi} sub-elements are present if the device supports MSI interrupts.
    The element count designates the number of supported MSI interrupts.

    See line \ref{lst:af-lineref-device-irq} in listing
    \ref{lst:annotated-policy} for an example device IRQ declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="msi" type="msiIrqType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of device IRQ resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="number" type="irqNumberType" use="required">
   <xs:annotation>
    <xs:documentation>
     Legacy or PCI line-based IRQ.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="msiIrqType">
  <xs:annotation>
   <xs:documentation>
    There are two different interrupt types which devices may trigger:
    legacy/PCI LSI IRQs and Message Signaled Interrupts (MSI). The legacy/PCI
    LSI IRQ is specified by the number attribute of the \texttt{irq} element.
    For MSIs, each \texttt{msi} element defines an MSI IRQ that may be assigned
    to subjects. Each MSI may be individually routed.

    See line \ref{lst:af-lineref-device-irq-msi} in listing
    \ref{lst:annotated-policy} for example device MSI elements.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of MSI resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="devicesRefType">
  <xs:annotation>
   <xs:documentation>
    List of device references. Used to grant a subject access to hardware
    devices and their resources.

    See line \ref{lst:af-lineref-devicerefs} in listing \ref{lst:annotated-policy}
    for example device references.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="device" type="deviceRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="deviceRefType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{device} element allows a subject access to devices referenced
    via the \texttt{physical} attribute.

    For PCI devices only a single virtual bus is provided (bus 0). The
    \texttt{pci} element may be used to place the device at a specific location
    (BDF).  If no other logical device resources of the device are specified,
    then the expander tool will map all physical devices resources into the
    subject.  When logical device resources are explicitly specified, then only
    access to those are actually granted.  The physical attribute must be either
    a reference to an existing physical device, device alias or device class.
    Validators check that this is the case.

    See line \ref{lst:af-lineref-deviceref} in listing \ref{lst:annotated-policy}
    for an example reference.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="pci" type="pciAddressType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="irq" type="irqRefType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="memory" type="devMemRefType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="ioPort" type="physicalRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical device name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of physical device to reference.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="physicalRefType">
  <xs:annotation>
   <xs:documentation>
    References a physical resource given by the \texttt{physical} attribute, and
    assigns a \texttt{logical} name to it.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name for resource reference.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of physical resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="eventsType">
  <xs:annotation>
   <xs:documentation>
    Events are an activity caused by a subject (source) that impacts a second
    subject (target) or is directed at the kernel. Events are declared globally
    and have a unique name to be unambiguous. An event must have a single source
    and one target.

    Subjects can use events to either deliver an interrupt, hand over execution to
    or reset the state of a target subject. The first kind of event provides a
    basic notification mechanism and enables the implementation of event-driven
    services. The second type facilitates suspension of execution of the source
    subject and switching to the target. Such a construct is used to pass the
    thread of execution on to a different subject, e.g. invocation of a debugger
    subject if an error occurs in the source subject. The third kind is used to
    facilitate the restart of subjects.

    An event can also have the same source and target, which is called
    \emph{self} event. Such events are useful to implement para-virtualized
    timers in VM subjects for example.

    Kernel events are special in that they are targeted at the kernel. The
    currently supported events are system reboot and shutdown.

    For documentation about linking physical events to source and target
    subjects, see section \ref{system_src.xsd:subjectEventsType}.

    See line \ref{lst:af-lineref-events} in listing \ref{lst:annotated-policy}
    for an example events section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="event" type="eventType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="eventSourceType">
  <xs:annotation>
   <xs:documentation>
    The event \texttt{source} element specifies events that are allowed to be
    triggered by the associated subject.

    Source events are divided into two groups: \texttt{vmx\_exit} and
    \texttt{vmcall}.  For event group \texttt{vmx\_exit} the id attribute
    specifies the trap number while in the \texttt{vmcall} group it designates
    the hypercall number.

    The \texttt{vmx\_exit} group is translated to a lookup table for handling
    VMX exit traps as defined by Intel SDM Vol. 3D, "Appendix C VMX Basic Exit
    Reasons".  The \texttt{vmcall} group on the other hand is translated into a
    lookup table to handle hypercalls.

    See line \ref{lst:af-lineref-subj-events-source} in listing
    \ref{lst:annotated-policy} for an example event source section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="group" type="eventGroupType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="eventTargetType">
  <xs:annotation>
   <xs:documentation>
    The event \texttt{target} element specifies events that the subject is an
    \emph{endpoint} of.

    See line \ref{lst:af-lineref-subj-events-target} in listing
    \ref{lst:annotated-policy} for an example event target section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="event" type="targetEventEntryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="sourceEventEntryType">
  <xs:annotation>
   <xs:documentation>
    A source \texttt{event} entry specifies a source event node, i.e. it
    registers a handler for the given event \texttt{id}. These IDs, depending on
    the event group, are either hypercall numbers or VMX basic exit reasons.

    It is possible to assign event actions to event source entries. Currently
    supported source event actions are \texttt{system\_reboot} and
    \texttt{system\_poweroff}, which both have the kernel itself as endpoint.

    See line \ref{lst:af-lineref-events-source-entry} in listing
    \ref{lst:annotated-policy} for a source event entry example.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="baseEventWithIDType">
    <xs:group ref="sourceEventActionsGroup" minOccurs="0" maxOccurs="1"/>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="baseEventType">
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical event name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Physical event name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="baseEventWithIDType">
  <xs:annotation>
   <xs:documentation>
    Base event with ID.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="baseEventType">
    <xs:attribute name="id" type="xs:nonNegativeInteger" use="required">
     <xs:annotation>
      <xs:documentation>
       ID of event.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:simpleType name="eventGroupNameType">
  <xs:annotation>
   <xs:documentation>
    Supported event groups.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="vmx_exit"/>
   <xs:enumeration value="vmcall"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="eventType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{eventType} specifies an event by name and mode.

    The following event modes are currently supported:
    \begin{itemize}
    \item \texttt{asap}~\\
    The asap event is an abstraction to state that the event should be delivered
    as soon as possible, depending on the CPU of the target subject. If the
    target runs on another CPU core, this mode is expanded to mode \emph{ipi},
    which is only available in policy formats A and B, instructing the kernel to
    preempt the kernel running the target subject and inject the event
    immediately. If the target subject runs on the same core as the source
    subject, the mode is expanded to mode \emph{async}.
    \item \texttt{async}~\\
    Async events trigger no preemption at the target subject. The event is
    marked as pending in the target subject's pending event table and inserted
    on the next VM exit/entry cycle of the target subject.
    \item \texttt{self}~\\
    An event can also have the same source and target, which is called a self
    event. Such events are useful to implement para-virtualized timers in VM
    subjects for example. A subject sends itself a delayed event, using the
    timed event mechanism. Note that a self event must always have a target
    action assigned, which is checked by the validator.
    \item \texttt{switch}~\\
    The switch mode facilitates suspension of execution of the source subject
    and switching to the target. This can only happen between subjects running
    on the same core. Such a construct is used to pass the thread of execution
    on to a different subject, e.g. invocation of a debugger subject if an error
    occurs in the source subject.
    \item \texttt{kernel}~\\
    These kinds of events are directed at the kernel an thus only specify a
    source since the target is the kernel. They are used to enable specific
    subjects to unmask level-triggered IRQs and trigger a system reboot,
    poweroff or explicit panic (crash audit slot allocation and reboot).
    \end{itemize}

    See line \ref{lst:af-lineref-events-entry} in listing
    \ref{lst:annotated-policy} for an example global event declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of the event.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="mode" type="eventModeType" use="required">
   <xs:annotation>
    <xs:documentation>
     Mode of the event.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="eventActionInjectInterruptType">
  <xs:annotation>
   <xs:documentation>
    Instructs the SK to inject a guest interrupt with given vector on event
    occurrence.

    See line \ref{lst:af-lineref-events-injintr} in listing
    \ref{lst:annotated-policy} for an example declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="vector" type="vectorType" use="required">
   <xs:annotation>
    <xs:documentation>
     Vector to inject on event occurrence.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="eventActionUnmaskIrqType">
  <xs:attribute name="number" type="irqNumberType" use="required"/>
 </xs:complexType><xs:complexType name="eventActionNoParamType">
  <xs:annotation>
   <xs:documentation>
    Source/target event action without parameters.
   </xs:documentation>
  </xs:annotation>
</xs:complexType>

<xs:group name="sourceEventActionsGroup">
   <xs:choice>
      <xs:group ref="group2" minOccurs="0"/>
      <xs:element name="system_reboot" type="eventActionNoParamType"/>
      <xs:element name="system_panic" type="eventActionNoParamType"/>
      <xs:element name="system_poweroff" type="eventActionNoParamType"/>
      <xs:element name="unmask_irq" type="eventActionUnmaskIrqType"/>
   </xs:choice>
</xs:group>
  <xs:group name="group2">
    <xs:choice>
       <xs:group ref="sourceEventActionsGroup" minOccurs="0"/>
    </xs:choice>
  </xs:group>

<xs:group name="targetEventActionsGroup">
  <xs:choice>
   <xs:element name="inject_interrupt" type="eventActionInjectInterruptType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="reset" type="eventActionNoParamType" minOccurs="0" maxOccurs="1"/>
  </xs:choice>
 </xs:group><xs:complexType name="deviceBaseType">
  <xs:sequence>
   <xs:element name="description" type="deviceDescriptionType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="pci" type="pciType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="irq" type="irqType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="memory" type="deviceMemoryType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="ioPort" type="ioPortType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="capabilities" type="capabilitiesType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Unique device name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="pciAddressType">
  <xs:annotation>
   <xs:documentation>
    PCI Bus, Device, Function triplet (BDF).
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="bus" type="byteType" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI Bus number.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="device" type="pciDeviceNumberType" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI Device number.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="function" type="pciFunctionNumberType" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI Function number.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:simpleType name="pciDeviceNumberType">
  <xs:annotation>
   <xs:documentation>
    PCI Device number.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="16#[0|1][0-9a-fA-F]#"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="pciFunctionNumberType">
  <xs:annotation>
   <xs:documentation>
    PCI Function number.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:nonNegativeInteger">
   <xs:maxInclusive value="7"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="deviceIdentificationType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{identification} element specifies the PCI device class, device,
    revision and vendor ID.

    For more information, consult the PCI Local Bus Specification,
    "Configuration Space Decoding".

    See line \ref{lst:af-lineref-hw-device-pci-id} in listing
    \ref{lst:annotated-policy} for an example PCI identification.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="classcode" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI device class.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="vendorId" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI vendor ID.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="deviceId" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI device ID.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="revisionId" type="byteType" use="required">
   <xs:annotation>
    <xs:documentation>
     PCI device revision ID.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="iommuGroupType">
  <xs:annotation>
   <xs:documentation>
    Devices in the same IOMMU group cannot be properly isolated from each other
    because they may perform inter-device transactions directly, without going
    through the IOMMU.

    Note that this information is currently not used by the toolchain. It is a
    hint to the system integrator whether two devices can be properly isolated
    from each other or not.

    See line \ref{lst:af-lineref-hw-device-iommugroup} in listing
    \ref{lst:annotated-policy} for an example IOMMU group declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="id" type="xs:nonNegativeInteger" use="required">
   <xs:annotation>
    <xs:documentation>
     IOMMU group number.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="devicesType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{devices} element enumerates all devices provided by the hardware platform.
    Different kinds of devices, be it PCI(e) or legacy (non-PCI), can be
    declared in this section.

    See line \ref{lst:af-lineref-hw-devices} in listing \ref{lst:annotated-policy}
    for an example devices enumeration.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="device" type="deviceType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="pciConfigAddress" type="word64Type" use="optional">
   <xs:annotation>
    <xs:documentation>
     Physical base address of the PCI configuration space region.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="processorType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{processor} element specifies the number of CPU cores, the
    processor speed in MHz and the Intel VMX preemption timer rate.

    Since Intel CPUs can have arbitrary APIC identifiers, the APIC IDs of all
    physical CPUs are enumerated here. The APIC ID is required for interrupt and
    IPI routing.

    See line \ref{lst:af-lineref-processor} in listing \ref{lst:annotated-policy}
    for an example processor element.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="cpu" type="cpuCoreType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="cpuCores" type="xs:positiveInteger" use="required">
  <xs:annotation>
   <xs:documentation>
    Number of available CPU cores. Note that this value designates physical,
    hardware cores, not Hyper-Threading (HT) \emph{threads}. HT is disabled on
    Muen.
   </xs:documentation>
  </xs:annotation>
  </xs:attribute>
  <xs:attribute name="speed" type="xs:positiveInteger" use="required">
   <xs:annotation>
    <xs:documentation>
     Tick rate of CPU cores in MHz.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="vmxTimerRate" type="vmxTimerRateType" use="required">
   <xs:annotation>
    <xs:documentation>
     The VMX-premption timer counts down at a rate proportional to that of the
     timestamp counter (TSC). This value specifies this proportion, see Intel
     SDM Vol. 3C, "25.5.1 VMX-Preemption Timer" for more details.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:simpleType name="vmxTimerRateType">
  <xs:annotation>
   <xs:documentation>
    VMX-preemption timer count down rate.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:nonNegativeInteger">
   <xs:maxInclusive value="31"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="capabilitiesType">
  <xs:annotation>
   <xs:documentation>
    List of device capabilities.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="capability" type="capabilityType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="capabilityType">
  <xs:annotation>
   <xs:documentation>
    A device \texttt{capability} is used to assign additional information to a
    device. Such a capability might be used by the Muen toolchain to perform
    certain actions on devices with a given capability (e.g. \texttt{ioapic}). A
    system integrator may use this facility to define its own capabilities used
    by custom tools.

    A capability element can have an optional value.

    See line \ref{lst:af-lineref-dev-cap} in listing \ref{lst:annotated-policy}
    for example capabilities.
   </xs:documentation>
  </xs:annotation>
  <xs:simpleContent>
   <xs:extension base="xs:string">
    <xs:attribute name="name" type="xs:string" use="required">
     <xs:annotation>
      <xs:documentation>
       Capability name (free text).
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:simpleContent>
 </xs:complexType><xs:simpleType name="deviceDescriptionType">
  <xs:annotation>
   <xs:documentation>
    Device description (free text).
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string"/>
 </xs:simpleType><xs:complexType name="kernelType">
  <xs:sequence>
   <xs:element name="memory" type="kernelMemMappingsType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="devices" type="devicesRefType" minOccurs="1" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="kernelMemMappingsType">
  <xs:sequence>
   <xs:element name="cpu" type="cpuMemoryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="cpuMemoryType">
  <xs:complexContent>
   <xs:extension base="memoryRefsType">
    <xs:attribute name="id" type="xs:nonNegativeInteger" use="required"/>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:simpleType name="memorySizeType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{memorySizeType} is used to declare memory sizes.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="word64Type"/>
 </xs:simpleType><xs:simpleType name="alignmentType">
  <xs:annotation>
   <xs:documentation>
    Memory alignment constraint for memory region. Taken into account by
    the allocator tool and checked by the validator.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="word64Type">
   <xs:enumeration value="16#1000#"/>
   <xs:enumeration value="16#0020_0000#"/>
   <xs:enumeration value="16#4000_0000#"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="cachingType">
  <xs:annotation>
   <xs:documentation>
    Memory caching type, see Intel SDM Vol. 3A, "11.3 Methods of Caching
    Available".

    \begin{itemize}
    \item Strong Uncacheable (UC)
    \item Write Combining (WC)
    \item Write Through (WT)
    \item Write Back (WB)
    \item Write Protected (WP)
    \end{itemize}
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="UC|WC|WT|WB|WP"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="memoryKindType">
  <xs:restriction base="xs:string">
   <xs:enumeration value="system"/>
   <xs:enumeration value="system_vmxon"/>
   <xs:enumeration value="system_iobm"/>
   <xs:enumeration value="system_msrbm"/>
   <xs:enumeration value="system_pt"/>
   <xs:enumeration value="system_vtd_root"/>
   <xs:enumeration value="system_vtd_context"/>
   <xs:enumeration value="system_vtd_ir"/>
   <xs:enumeration value="kernel"/>
   <xs:enumeration value="kernel_binary"/>
   <xs:enumeration value="kernel_fpu"/>
   <xs:enumeration value="kernel_interface"/>
   <xs:enumeration value="kernel_msrstore"/>
   <xs:enumeration value="kernel_vmcs"/>
   <xs:enumeration value="subject"/>
   <xs:enumeration value="subject_info"/>
   <xs:enumeration value="subject_state"/>
   <xs:enumeration value="subject_binary"/>
   <xs:enumeration value="subject_channel"/>
   <xs:enumeration value="subject_crash_audit"/>
   <xs:enumeration value="subject_initrd"/>
   <xs:enumeration value="subject_bios"/>
   <xs:enumeration value="subject_acpi_rsdp"/>
   <xs:enumeration value="subject_acpi_xsdt"/>
   <xs:enumeration value="subject_acpi_fadt"/>
   <xs:enumeration value="subject_acpi_dsdt"/>
   <xs:enumeration value="subject_zeropage"/>
   <xs:enumeration value="subject_solo5_boot_info"/>
   <xs:enumeration value="subject_device"/>
   <xs:enumeration value="subject_scheduling_info"/>
   <xs:enumeration value="subject_timed_event"/>
   <xs:enumeration value="subject_interrupts"/>
   <xs:enumeration value="device_rmrr"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="memoryBlockBaseType" abstract="true">
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of memory block.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physicalAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Start address of memory block.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="size" type="memorySizeType" use="required">
   <xs:annotation>
    <xs:documentation>
     Size of memory block.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="deviceMemoryType">
  <xs:annotation>
   <xs:documentation>
    A device \texttt{memory} element specifies a memory region which is used to
    interact with the associated device.

    For PCI devices, the specified region is programmed into one device BAR
    (Base Address Register) by system firmware. See the PCI Local Bus
    Specification or the PCI Express Base Specification for more details.

    See line \ref{lst:af-lineref-devmem} in listing \ref{lst:annotated-policy}
    for an example device memory declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="memoryBlockBaseType">
    <xs:attribute name="caching" type="cachingType" use="required">
     <xs:annotation>
      <xs:documentation>
       Device memory caching type.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:simpleType name="optionalOffsetType">
  <xs:annotation>
   <xs:documentation>
    Optional file offset value in bytes.
   </xs:documentation>
  </xs:annotation>
  <xs:union memberTypes="word64Type noneType"/>
 </xs:simpleType><xs:complexType name="fillContentType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{fill} element designates a memory region which is initialized
    with the given pattern.

    See line \ref{lst:af-lineref-memory-fill} in listing
    \ref{lst:annotated-policy} for a file-backed memory region example.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="pattern" type="byteType" use="required">
   <xs:annotation>
    <xs:documentation>
     Fill pattern (hex).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="memRegionsType">
  <xs:annotation>
   <xs:documentation>
    This section declares all physical memory regions (RAM) and thus the
    physical memory layout of the system. Regions declared in this section can
    be assigned to subjects and device domains.

    Memory regions are defined by the following attributes:
    \begin{itemize}
    \item Name
    \item Caching type
    \item Size
    \item Physical address*
    \item Alignment*
    \item Memory type*
    \end{itemize}

    Attributes with an asterisk are optional. While alignment and memory type
    are set to a default value if not specified, the physical address is filled
    in by the allocator tool, which allocates all memory regions and finalizes
    the physical memory layout.

    Additionally, the content of a region can be declared as backed by a file or
    filled with a pattern.

    Note: The caching type is an attribute of the physical memory region by
    design to avoid inconsistent typing, even though the Intel Page Attribute
    Table (PAT) mechanism allows to set it for each memory mapping, see Intel
    SDM Vol. 3A, "11.12.4 Programming the PAT".

    See line \ref{lst:af-lineref-physmem} in listing \ref{lst:annotated-policy}
    for an example memory region section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memory" type="memoryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="memRefType">
  <xs:annotation>
   <xs:documentation>
    A \texttt{memory} element maps a physical memory region into the address
    space of a device domain or subject entity. The region will be accessible
    to the entity at the specified \texttt{virtualAdress} with permissions
    defined by the \texttt{executable} and \texttt{writable} attributes.

    See line \ref{lst:af-lineref-memref} in listing \ref{lst:annotated-policy}
    for an example of such a mapping.
   </xs:documentation>
  </xs:annotation>
  <xs:attributeGroup ref="memRefBaseAttrs"/>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Address in entity address space where the physical memory region is mapped.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="memoryRefsType">
  <xs:annotation>
   <xs:documentation>
    List of physical memory region references.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memory" type="memRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:attributeGroup name="memBaseAttrs">
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of mapping.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="writable" type="booleanType" use="required">
   <xs:annotation>
    <xs:documentation>
     Defines if the mapped memory is writable.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="executable" type="booleanType" use="required">
   <xs:annotation>
    <xs:documentation>
     Defines if the memory region contents are executable by the processor.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup><xs:attributeGroup name="memRefBaseAttrs">
  <xs:attributeGroup ref="memBaseAttrs"/>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of referenced physical memory region.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup><xs:complexType name="memoryBaseType" abstract="true">
  <xs:sequence>
   <xs:choice minOccurs="0" maxOccurs="1">
    <xs:element name="file" type="fileContentType"/>
    <xs:element name="fill" type="fillContentType"/>
   </xs:choice>
   <xs:choice minOccurs="0" maxOccurs="1">
    <xs:element name="hash" type="hash256Type"/>
    <xs:element name="hashRef" type="hashRefType"/>
   </xs:choice>
  </xs:sequence>
  <xs:attribute name="size" type="memorySizeType" use="required">
   <xs:annotation>
    <xs:documentation>
     Size of region. Must be a multiple of page size (4K). Enforced by validator.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="physicalMemBaseType">
  <xs:complexContent>
   <xs:extension base="memoryBaseType">
    <xs:attribute name="name" type="nameType" use="required">
     <xs:annotation>
      <xs:documentation>
       Name of region.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
    <xs:attribute name="caching" type="cachingType" use="required">
     <xs:annotation>
      <xs:documentation>
       Caching type to use for memory region.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:simpleType name="hash256DigestType">
  <xs:annotation>
   <xs:documentation>
    256-Bits (32 octets) hash digest in hexadecimal (Ada notation).
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="16#[0-9a-fA-F]{64}#"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="optionalHashType">
  <xs:annotation>
   <xs:documentation>
    Allows the specification of a hash digest or \texttt{none}.
   </xs:documentation>
  </xs:annotation>
  <xs:union memberTypes="hash256DigestType noneType"/>
 </xs:simpleType><xs:complexType name="hash256Type">
  <xs:annotation>
   <xs:documentation>
    The \texttt{hash} child element of a memory region designates a 256-bit hash
    over the memory content.

    The Mucfgmemhashes tool in the Muen toolchain generates such a hash-sum for
    every content-backed memory region in a given policy.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="value" type="optionalHashType" use="required">
   <xs:annotation>
    <xs:documentation>
     256-Bits message digest over file-backed memory content.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="hashRefType">
  <xs:annotation>
   <xs:documentation>
    The optional \texttt{hashRef} child element of a physical memory region
    instructs the Mucfgmemhashes tool to copy the hash element of the referenced
    memory region after message digest generation.

    From an abstract point of view, the \texttt{hashRef} element is a way to
    link multiple memory regions by declaring that the hash of the content is
    the same. This concept is e.g. used by the subject loader mechanism to
    restore writable memory regions to their initial state.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="memory" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of referenced physical memory region.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="aliasesType">
  <xs:annotation>
   <xs:documentation>
    Aliases are a renaming mechanism for physical hardware devices and their
    resources. By using alias names in the system policy references to
    concrete hardware resources can be avoided.
    Additionally, aliases may be used to define a device which only contains a
    subset of the resources of the physical device. This can be achieved by
    only renaming the resources that the device alias should export.

    See line \ref{lst:af-lineref-aliases} in listing \ref{lst:annotated-policy}
    for an example aliases section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="alias" type="namePhysRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="namePhysRefType">
  <xs:annotation>
   <xs:documentation>
    Named resource reference. Used for device aliases and device alias resource
    references.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="resource" type="namePhysRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Alias name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Reference to physical device or device resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="devClassesType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{classes} element specifies a list of device classes.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="class" type="devClassType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="devClassType">
  <xs:annotation>
   <xs:documentation>
    Device classes enable the grouping of devices and allow referencing all
    devices by a single name. This simplifies the process of assigning multiple
    devices to a subject.

    Note: A device class may contain an arbitrary number of devices, including
    zero.

    See line \ref{lst:af-lineref-devclass} in listing \ref{lst:annotated-policy}
    for a device class example.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="device" type="physRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Device class name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="physRefType">
  <xs:annotation>
   <xs:documentation>
    Reference to physical device or physical device resource.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Physical resource name (device or resource sub-element).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="kernelDiagType">
  <xs:annotation>
   <xs:documentation>
    The debug build Muen SK can be instructed to output debugging information
    during runtime. The platform diagnostics device specifies which device the
    kernel is to use for this purpose.

    The presence of this device and the necessary resources are checked by the
    validator tool.

    See line \ref{lst:af-lineref-diagdev} in listing \ref{lst:annotated-policy}
    for an example platform diagnostic device configuration.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="device" type="kernelDiagDeviceType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
  <xs:attribute name="type" type="kernelDiagKindType" use="required">
   <xs:annotation>
    <xs:documentation>
     Specifies the type of diagnostics device to use.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:simpleType name="kernelDiagKindType">
  <xs:annotation>
   <xs:documentation>
    Type of diagnostics device. While \texttt{none} disables kernel diagnostics
    output, \texttt{uart} specifies an Universal Asynchronous
    Receiver-Transmitter serial device. \texttt{hsuart} is a High-Speed UART
    with memory mapped I/O.

    \texttt{vga} outputs the kernel diagnostics information to a VGA console,
    which is mainly useful for initial bring-up of a new hardware platform with
    no UART device.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="none"/>
   <xs:enumeration value="uart"/>
   <xs:enumeration value="hsuart"/>
   <xs:enumeration value="vga"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="kernelDiagDeviceType">
  <xs:annotation>
   <xs:documentation>
    Reference to physical device for \texttt{uart} and \texttt{vga} diagnostic
    device type.

    If an UART device is referenced via type \texttt{uart}, an I/O port resource
    must be provided. If a VGA device is referenced via type \texttt{vga}, a
    memory resource must be provided (both checked via validator).
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memory" type="physRefType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="ioPort" type="physRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of physical device to use for kernel diagnostics output.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="schedulingType">
  <xs:annotation>
   <xs:documentation>
    The Muen SK implements a fixed, cyclic scheduler. The \texttt{scheduling}
    element is used to specify such a static plan by means of a major frame. A
    major frame consist of an arbitrary number of minor frames.  Minor frames in
    turn specify a duration in number of ticks a subject is scheduled before
    preemption in terms of the tick rate.

    The tickRate attribute has the unit Hertz (Hz) and specifies the number of
    clock ticks per second. The ticks attribute of minor frames is expressed in
    terms of this tick rate. As an example: if we want to declare the minor
    frame duration in terms of microseconds ($10^{-6}$) then a tick rate of
    1000000 must be used.

    The duration of a major frame must be the same on each CPU, meaning the sum
    of all minor frame ticks for any given CPU must be identical. However,
    different major frames can have arbitrary length.

    The Tau0 subject designates to the kernel which major frame is the currently
    active one. At the end of each major frame, the kernel determines the active
    major frame and switches to that scheduling plan for the duration of the
    major frame.

    All subjects which can hand over execution to another subject via a switch
    event form a so called scheduling group. Membership to a scheduling group is
    determined by the specified switch events and how they link subjects
    together. Minor frames designate the subject that is to be executed for the
    given amount of ticks. The subject name identifies the \emph{initial}
    subject of a minor frame but any member of the scheduling group of the given
    subject may be executed during that minor frame.

    See line \ref{lst:af-lineref-sched} in listing \ref{lst:annotated-policy}
    for an example scheduling plan.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="majorFrame" type="majorFrameType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="tickRate" type="xs:positiveInteger" use="required">
   <xs:annotation>
    <xs:documentation>
     Scheduling clock ticks in Hz.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="cpuType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{cpu} element is used to specify major frames for each CPU of the
    system.

    See line \ref{lst:af-lineref-sched-cpu} in listing
    \ref{lst:annotated-policy} for an example cpu element.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="minorFrame" type="minorFrameType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="id" type="xs:nonNegativeInteger" use="required">
   <xs:annotation>
    <xs:documentation>
     ID of CPU.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:attributeGroup name="subjectBaseAttrs">
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Unique subject name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup><xs:complexType name="subjectEventsType">
  <xs:annotation>
   <xs:documentation>
    The subject \texttt{events} element specifies all events originating from or
    directed at this subject. The physical attribute is the name of a event
    defined in the global events section.

    See line \ref{lst:af-lineref-subject-evt} in listing
    \ref{lst:annotated-policy} for an example subject events section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="source" type="eventSourceType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="target" type="eventTargetType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="subjectsType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{subjects} element holds a list of subjects.

    See line \ref{lst:af-lineref-subjects} in listing \ref{lst:annotated-policy}
    for an example subjects section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="subject" type="subjectType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:simpleType name="word64Type">
  <xs:annotation>
   <xs:documentation>
    64-bit machine word.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="16#[0-9a-fA-F]{4}(_([0-9a-fA-F]{4})){0,3}#"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="word32Type">
  <xs:annotation>
   <xs:documentation>
    32-bit machine word.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="word64Type">
   <xs:maxLength value="13"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="word16Type">
  <xs:annotation>
   <xs:documentation>
    16-bit machine word.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="word64Type">
   <xs:length value="8"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="byteType">
  <xs:annotation>
   <xs:documentation>
    Machine octet (8-bits).
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="16#[0-9a-fA-F]{2}#"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="booleanType">
  <xs:annotation>
   <xs:documentation>
    Boolean type.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="true"/>
   <xs:enumeration value="false"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="nameType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{nameType} is used to give (unique) names to elements.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:minLength value="1"/>
   <xs:maxLength value="63"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="namedRefType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{namedRefType} is used to reference a named element in the policy.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="ref" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of referenced element.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:simpleType name="noneType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{noneType} is used to designate 'does not apply here', 'unavailable'.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="none"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="bitValueType">
  <xs:annotation>
   <xs:documentation>
    The value of one bit, either 1 (True) 0 (False).
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:nonNegativeInteger">
   <xs:minInclusive value="0"/>
   <xs:maxInclusive value="1"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="msrModeType">
  <xs:annotation>
   <xs:documentation>
    MSR access rights.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="r"/>
   <xs:enumeration value="w"/>
   <xs:enumeration value="rw"/>
  </xs:restriction>
 </xs:simpleType><xs:simpleType name="msrAddressType">
  <xs:annotation>
   <xs:documentation>
    Start/end address value for MSRs in the low or high range:
    \begin{itemize}
    \item Low  : \texttt{16\#0000\_0000\# .. 16\#0000\_1fff\#}
    \item High : \texttt{16\#C000\_0000\# .. 16\#C000\_1fff\#}
    \end{itemize}

    See also Intel SDM Vol. 3C, "24.6.9 MSR-Bitmap Address".
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:pattern value="16#([cC0]000_)?[01]([0-9a-fA-F]{3})#"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="msrType">
  <xs:annotation>
   <xs:documentation>
    An \texttt{msr} element allows a subject direct access to the specified
    model-specific register (MSR).

    \begin{warning}
    Deviating from the settings provided by the component vCPU profile might
    result in unexpected system behavior. A system integrator granting direct
    access to MSRs must be aware of the potential side-effects.
    \end{warning}
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="start" type="msrAddressType" use="required">
  <xs:annotation>
   <xs:documentation>
    MSR start address.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
 <xs:attribute name="end" type="msrAddressType" use="required">
  <xs:annotation>
   <xs:documentation>
    MSR end address.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
 <xs:attribute name="mode" type="msrModeType" use="required">
  <xs:annotation>
   <xs:documentation>
    MSR access permissions.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
</xs:complexType><xs:complexType name="msrsType">
  <xs:annotation>
   <xs:documentation>
    List of model-specific registers (MSRs) a subject is allowed to access. The
    settings in this section are translated to the MSR bitmaps of the associated
    subject (as described by Intel SDM Vol.  3C, "24.6.9 MSR-Bitmap Address").
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="msr" type="msrType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="segmentType">
  <xs:annotation>
   <xs:documentation>
    Initial value of a segment register, including hidden part. See Intel SDM
    Vol. 3A, "3.4.3 Segment Registers" for more details on segment registers.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="selector" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Segment selector value.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="base" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Segment base address.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="limit" type="word32Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Segment limit.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="access" type="word32Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Segment access information.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="deviceDomainsType">
  <xs:annotation>
   <xs:documentation>
    The physical memory accessible by PCI devices is specified by so called
    device domains. Such domains define memory mappings of physical memory
    regions for one or multiple devices. Device references select a subset of
    hardware devices provided by the hardware/platform. Devices may be
    referenced by device name, alias or device class.

    Device references can optionally set the \texttt{mapReservedMemory}
    attribute so RMRR regions referenced by the device are also mapped into
    the device domain.

    Device domains are isolated from each other by the use of Intel VT-d.

    See line \ref{lst:af-lineref-devdom} in listing \ref{lst:annotated-policy}
    for a device domain example.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="domain" type="deviceDomainType" minOccurs="0" maxOccurs="255"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="devsRefType">
  <xs:annotation>
   <xs:documentation>
    Device domain device references.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="device" type="devRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="devMemRefType">
  <xs:annotation>
   <xs:documentation>
    The device \texttt{memory} element maps the device memory region referenced
    via the \texttt{physical} attribute into the subject address space at
    address \texttt{virtualAddress}. The \texttt{executable}, \texttt{writable}
    attributes define the access permissions for the subject.

    See line \ref{lst:af-lineref-deviceref-mem} in listing
    \ref{lst:annotated-policy} for an example device memory reference.
   </xs:documentation>
  </xs:annotation>
  <xs:attributeGroup ref="memRefBaseAttrs"/>
  <xs:attribute name="virtualAddress" type="word64Type" use="optional">
   <xs:annotation>
    <xs:documentation>
     Address of mapping in subject address space. If none is specified, an
     identity mapping is applied by the expander tool.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="irqRefType">
  <xs:annotation>
   <xs:documentation>
    The device \texttt{irq} element assigns the referenced physical IRQ to the
    subject, i.e. if the device triggers the referenced physical IRQ, the
    specified \texttt{vector} number will be injected into the subject by the
    SK.

    The presence of \texttt{msi} sub-elements enforces MSI mode (the default for
    MSI-capable devices and automatic device resource expansion).
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="msi" type="physicalRefType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical IRQ name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of physical device IRQ.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="vector" type="vectorType" use="optional">
   <xs:annotation>
    <xs:documentation>
     Vector to inject into subject if device triggers IRQ. Will be allocated by
     the expander if none is specified.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="eventGroupType">
  <xs:annotation>
   <xs:documentation>
    Source event group element. Currently, two groups are supported:
    \texttt{vmcall} for hypercalls and \texttt{vmx\_exit} for all other supported
    traps.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="default" type="defaultEventEntryType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="event" type="sourceEventEntryType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="name" type="eventGroupNameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of event group.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="baseDefaultEventType">
  <xs:annotation>
   <xs:documentation>
    Base default event.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Global event reference.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="defaultEventEntryType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{default} element entry can be used to specify an event which
    should be added for all event ids that have not been explicitly specified.

    See line \ref{lst:af-lineref-subj-events-source-default} in listing
    \ref{lst:annotated-policy} for a default source event example.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="baseDefaultEventType">
    <xs:group ref="sourceEventActionsGroup" minOccurs="0" maxOccurs="1"/>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="targetEventEntryType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{event} element in the target section specifies one event
    endpoint by referencing a physical event and assigning a logical name to it.

    See line \ref{lst:af-lineref-subj-events-target-ev} in listing
    \ref{lst:annotated-policy} for an example event endpoint.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="baseEventType">
    <xs:group ref="targetEventActionsGroup" minOccurs="0" maxOccurs="1"/>
    <xs:attribute name="id" type="xs:nonNegativeInteger" use="optional">
     <xs:annotation>
      <xs:documentation>
       Event ID.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:simpleType name="eventModeType">
  <xs:annotation>
   <xs:documentation>
    Event mode.

    See \ref{system_src.xsd:eventType} for details about the supported event modes.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="asap"/>
   <xs:enumeration value="async"/>
   <xs:enumeration value="self"/>
   <xs:enumeration value="switch"/>
   <xs:enumeration value="kernel"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="memoryType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{memoryType} specifies a physical memory region by name, size and
    caching.

    If no explicit physical address is specified for the region, the
    \texttt{mucfgalloc} tool will allocate a free one in usable memory, honoring
    the optional \texttt{alignment} attribute.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="physicalMemBaseType">
    <xs:attribute name="type" type="subjectMemoryKindType" use="optional">
     <xs:annotation>
      <xs:documentation>
       Optional subject memory type.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
    <xs:attribute name="alignment" type="alignmentType" use="optional">
     <xs:annotation>
      <xs:documentation>
       Alignment the physical address of the memory region must honor (checked
       by the validator tool).
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
    <xs:attribute name="physicalAddress" type="word64Type" use="optional">
     <xs:annotation>
      <xs:documentation>
       Physical address of memory region.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="memoryBlockType">
  <xs:annotation>
   <xs:documentation>
    Consecutive block of memory provided by the hardware.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="memoryBlockBaseType">
    <xs:attribute name="allocatable" type="booleanType" use="optional">
     <xs:annotation>
      <xs:documentation>
       Indication to a physical memory allocator that this block allows
       allocation of physical memory regions. If this attribute is false, an
       allocator should only place fixed memory regions in this range, i.e.
       memory regions with the \texttt{physicalAddress} attribute set by the
       integrator.

       Note that host physical memory below 1 MiB is considered special, the
       attribute must be set to false. Only unmapped memory of type
       \emph{system} is allowed in that special memory block.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="reservedMemRegionType">
  <xs:annotation>
   <xs:documentation>
    A \texttt{reservedMemory} element is a special memory block declaration. It
    specifies a reserved memory region as outlined in the Intel VT-d
    Specification, "8.4 Reserved Memory Region Reporting Structure" (RMRR).

    Reserved memory regions are BIOS allocated memory ranges that may be DMA
    targets for certain legacy device use-cases. Devices that require access to
    such a region refer to it by name.

    See line \ref{lst:af-lineref-rmrr-block} in listing \ref{lst:annotated-policy}
    for an example RMRR element.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="memoryBlockBaseType"/>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="fileContentType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{file} child element designates a file-backed memory region.

    The \texttt{filename} attribute specifies the name of the file to use as
    content for the physical memory region, the \texttt{offset} attribute is
    \texttt{none} by default but can be customized to include a partial file.

    See line \ref{lst:af-lineref-memory-file} in listing
    \ref{lst:annotated-policy} for a file-backed memory region example.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="filename" type="xs:string" use="required">
   <xs:annotation>
    <xs:documentation>
     Filename of file to (partially) include. Note that the actual file
     processed by the toolchain also depends on the working directory passed as
     command line option to the specific tool.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="offset" type="optionalOffsetType" use="required">
   <xs:annotation>
    <xs:documentation>
     Read file offset in bytes.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:simpleType name="subjectMemoryKindType">
  <xs:annotation>
   <xs:documentation>
    Subject memory type to categorize memory assigned to a subject. The
    validator tool checks that a subject only maps memory regions of types
    outlined in this section (\ref{validation-subj}).

    Also used by build tools to lookup certain elements by type. For example,
    the \texttt{mugenzp} tool looks for subject memory of type
    \texttt{subject\_zeropage} to process all Linux zero-pages in the policy.

    The following memory types are currently supported:

    \begin{itemize}
    \item \texttt{subject}~\\
    Generic subject memory, used e.g. for RAM regions of VM subjects.  The
    \texttt{mugenzp} tool used for Linux VMs (\ref{tools-mugenzp}) exports such
    regions as \texttt{E820\_RAM} in the ZP E820 memory map.
    \item \texttt{subject\_info}~\\
    Subject info (sinfo) region provided to all subjects. The sinfo region is
    used to query information about the execution environment. The file backing
    of this region is created by the \texttt{mugensinfo} tool
    (\ref{tools-mugensinfo}).
    \item \texttt{subject\_state}~\\
    Subject execution state. Mapped into the SK kernel executing the given
    subject, kernels running on other CPUs have no access. Accessible by subject
    monitors running on the same CPU if specified in the policy. Validator
    enforces that each subject has an associated \texttt{subject\_state} region
    and that it is mapped at the expected virtual address in the executing
    kernel (\ref{validation-subj}).
    \item \texttt{subject\_binary}~\\
    Subject executable as a whole or separate subject executable regions (text,
    rodata, data, bss, stack) with access rights (writable/executable). The
    \texttt{mucbinsplit} tool automatically creates a component
    \texttt{provides} section with separate binary regions and associated
    backing files from a component binary (\ref{tools-mucbinsplit}).
    \item \texttt{subject\_channel}~\\
    Physical memory region used as shared channel between two subjects. The
    expander tool transforms channels in system policy source format to memory
    regions with this type in system policy format A/B, as described in section
    \ref{system_src.xsd:channelsType}.
    \item \texttt{subject\_crash\_audit}~\\
    Memory region used by crash audit facility to store system crash information
    into slots, see \cite{muen:kernel-spec}. This information is preserved after
    a crash by performing a system warm start. Validators enforce that
    \begin{itemize}
    \item Region is present and uncached, \ref{validation-mem}
    \item Region does not overlap with image, \ref{validation-mem}
    \item Kernel mappings are present and correct, \ref{validation-knl}
    \item No subject has write access to this region, \ref{validation-subj}
    \end{itemize}
    \item \texttt{subject\_initrd}~\\
    Physical memory of this type designates an \emph{initial ramdisk}. This
    memory type is mostly used by Linux VMs. If multiple initrd regions are
    mapped into a subject, they must be adjacent (\ref{validation-subj}).

    The \texttt{mugenzp} tool (\ref{tools-mugenzp}) extracts the virtual address
    and size of a subject-mapped region of this memory type and stores the
    values in the generated Linux zero-page (ZP) backing file.
    \item \texttt{subject\_bios}~\\
    Indicates to subjects that the memory region is reserved for BIOS/firmware
    and must not be used as regular RAM.
    \item \texttt{subject\_acpi\_*}~\\
    Indicates to subjects that the memory region contains an ACPI table. See the
    ACPI specification for more information about RSDP, XSDT, FADT and DSDT ACPI
    tables. The \texttt{mugenzp} tool (\ref{tools-mugenzp}) exports such regions
    as \texttt{E820\_ACPI} in the ZP E820 memory map.
    \item \texttt{subject\_zeropage}~\\
    Indicates to Linux subjects that the memory region contains a zero-page. See
    the Linux kernel Zero Page documentation for more information.
    \item \texttt{subject\_solo5\_boot\_info}~\\
    Indicates to a VM running Solo5/Mirage that the memory region contains a
    boot info structure. The file-backing of such a region may be created using
    the \texttt{mugensolo5} tool (\ref{tools-mugensolo5}).
    \item \texttt{subject\_device}~\\
    Designates a memory region which is allowed to be added to a subject and a
    device domain. The difference to the \texttt{subject} memory type is that
    the region is not exported as \texttt{E820\_RAM} but \texttt{E820\_RESERVED}
    to Linux subjects. Therefore, such a region is useful to implement custom
    drivers without interference from Linux DMA zone handling.
    \item \texttt{subject\_timed\_event}~\\
    Region designates a subject timed event page, as described in
    \cite{muen:component-spec}. The expander tool creates a physical memory
    region for each subject and maps it into the associated subject and the SK
    kernel executing this subject.
    \end{itemize}
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="memoryKindType">
   <xs:enumeration value="subject"/>
   <xs:enumeration value="subject_info"/>
   <xs:enumeration value="subject_state"/>
   <xs:enumeration value="subject_binary"/>
   <xs:enumeration value="subject_channel"/>
   <xs:enumeration value="subject_crash_audit"/>
   <xs:enumeration value="subject_initrd"/>
   <xs:enumeration value="subject_bios"/>
   <xs:enumeration value="subject_acpi_rsdp"/>
   <xs:enumeration value="subject_acpi_xsdt"/>
   <xs:enumeration value="subject_acpi_fadt"/>
   <xs:enumeration value="subject_acpi_dsdt"/>
   <xs:enumeration value="subject_zeropage"/>
   <xs:enumeration value="subject_solo5_boot_info"/>
   <xs:enumeration value="subject_device"/>
   <xs:enumeration value="subject_timed_event"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="majorFrameType">
  <xs:annotation>
   <xs:documentation>
    A major frame consists of a sequence of minor frames for a given CPU. When
    the end of a major frame is reached, all CPUs synchronize and the scheduler
    starts over from the beginning using the first minor frame again. This means
    that major frames are repeated in a cyclic fashion until a different major
    frame is designated via the Tau0 interface.

    See line \ref{lst:af-lineref-sched-major} in listing
    \ref{lst:annotated-policy} for an example major frame.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="cpu" type="cpuType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="minorFrameType">
  <xs:annotation>
   <xs:documentation>
    A minor frame specifies the number of scheduling ticks a subject is allowed
    to run on the CPU specified by the parent \texttt{cpu} element.

    See line \ref{lst:af-lineref-sched-minor} in listing
    \ref{lst:annotated-policy} for an example minor frame.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="subject" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of scheduled subject.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="ticks" type="xs:positiveInteger" use="required">
   <xs:annotation>
    <xs:documentation>
     Number of scheduling ticks in minor frame.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="subjectType">
  <xs:annotation>
   <xs:documentation>
    A subject is an instance of a component, i.e. an active component in the
    system policy that may be scheduled. Its specification references a
    component and maps all requested logical resources to physical resources
    provided by the system.  Additional resources to the ones requested by the
    component can be specified here. This enables specialization of the base
    component specification.

    See line \ref{lst:af-lineref-subject} in listing \ref{lst:annotated-policy}
    for an example subject declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="vcpu" type="vcpuType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="bootparams" type="xs:string" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="memory" type="memoryRefsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="devices" type="devicesRefType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="events" type="subjectEventsType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="channels" type="channelReferencesType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="monitor" type="monitorType" minOccurs="0" maxOccurs="1"/>
   <xs:choice minOccurs="1" maxOccurs="1">
    <xs:element name="component" type="componentReferenceType"/>
    <xs:element name="sibling" type="namedRefType"/>
   </xs:choice>
  </xs:sequence>
  <xs:attributeGroup ref="subjectBaseAttrs"/>
 </xs:complexType><xs:complexType name="monitorType">
  <xs:annotation>
   <xs:documentation>
    The monitor abstraction enables subjects to request access to certain data
    of another subject specified by name. Possible child elements are:

    \begin{itemize}
    \item State
    \item Timed\_Events
    \item Interrupts
    \item Loader
    \end{itemize}

    See the Muen Component Specification document for details about these
    subject monitor interfaces.

    See line \ref{lst:af-lineref-subject-monitor} in listing
    \ref{lst:annotated-policy} for an example monitor section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="state" type="monitorSubjectRefType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="timed_event" type="monitorSubjectRefType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="interrupts" type="monitorSubjectRefType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="loader" type="loaderSubjectRefType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="loaderSubjectRefType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{loader} mechanism effectively puts the loaded subject denoted by
    the \texttt{subject} attribute under loader control, as it is not able to
    start without the help of the loader.

    In more detail, the \texttt{loader} monitor element instructs the expander
    tool to map all memory regions of the referenced subject into the address
    space of the monitor subject, using the specified \texttt{virtualAddress} as
    offset in the address space of the loader.

    If a memory region of the loaded subject is writable and file-backed, the
    region is replaced with an empty region and linked via the \texttt{hashRef}
    mechanism to the original region which is mapped into the loader.

    The state of the loaded subject is then invalidated by clearing the
    \texttt{CR4.VMXE} bit in the initial subject CR4 register value. If such a
    subject is scheduled by the kernel, a VMX exit \emph{VM-entry failure due to
    invalid guest state} (33) occurs. See Intel SDM Vol. 3C, "23.7 Enabling and
    Entering VMX Operation" and Intel SDM Vol. 3C, "23.8 Restrictions on VMX
    Operation" for more details. This trap is linked to the loader via normal
    VMX event handling. After handover, the loader initializes the memory
    regions replaced by the expander with the designated content.

    All information required to \emph{load} the loaded subject is provided to
    the loader subject via its own sinfo API. Memory regions prefixed with
    \texttt{monitor\_sinfo\_} provide access to the sinfo regions of the loaded
    subjects. Regions prefixed with \texttt{monitor\_state\_} specify memory
    regions containing the subject register state of the loaded subject.

    The difference between the \texttt{monitor\_sinfo\_} memory region address
    in the loader and the address of the \texttt{sinfo} memory region in the
    target sinfo information denotes the \texttt{virtualAddress} offset
    attribute of the \texttt{loader} element in the policy. This information
    combined is enough to fully construct the initial state of the loaded
    subject, or to reset a subject to its initial state on demand.

    The loader may also optionally check the hashes of the restored regions, as
    this information is provided via the sinfo mechanism as well.

    See line \ref{lst:af-lineref-subject-mon-loader} in listing
    \ref{lst:annotated-policy} for an example loader element.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="subject" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of monitored subject.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of state mapping.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Address to map requested subject address space.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="monitorSubjectRefType">
  <xs:annotation>
   <xs:documentation>
    Give subject monitor (SM) access to the referenced subject state.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="loaderSubjectRefType">
    <xs:attribute name="writable" type="booleanType" use="required">
     <xs:annotation>
      <xs:documentation>
       Whether or not the given state is mapped writable into the SM.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="componentReferenceType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{component} reference element specifies which component this
    subject instantiates. All logical resources required by the component must
    be mapped to physical resources of the appropriate type. Validators make
    sure that all requirements are satisfied and that no mapping has been
    omitted.

    See line \ref{lst:af-lineref-subject-comp} in listing
    \ref{lst:annotated-policy} for an example component reference.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="map" type="resourceMappingType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="ref" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of referenced component.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="resourceMappingType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{map} element maps a physical resource provided by the system
    with a resource requested by the referenced component.

    This element allows recursion to map child resources as well (e.g. device
    memory, I/O ports etc).

    See line \ref{lst:af-lineref-subject-compress} in listing
    \ref{lst:annotated-policy} for an example mapping.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="map" type="resourceMappingType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of logical resource requested by the component.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Physical name of resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="channelsType">
  <xs:annotation>
   <xs:documentation>
    Inter-subject communication is specified by so called channels. These
    channels represent directed information flows since they have a single
    writer and possibly multiple readers. Optionally a channel can have an
    associated notification event (doorbell interrupt).

    Channels are declared globally and have an unique name to be unambiguous.

    Note that channels are a policy source format abstraction. The toolchain
    resolves this concept into memory regions and events as well as the
    appropriate subject mappings.

    For documentation about linking physical channels to subjects see section
    \ref{system_src.xsd:channelReferencesType}. For documentation about
    declaring requested channels in components see section
    \ref{system_src.xsd:logicalChannelsType}. For information how to map a
    physical channel with a logical component channel at subject level, see
    section \ref{system_src.xsd:resourceMappingType}.

    See line \ref{lst:af-lineref-channels} in listing \ref{lst:annotated-policy}
    for an example channel section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="channel" type="channelType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="channelType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{channel} element declares a physical channel.

    Besides the \texttt{name} and \texttt{size} of the channel, the optional
    \texttt{hasEvent} attribute can be set to declare that the given channel
    requests an associated event. The expander tool will then automatically
    create a global event of the requested event type.

    See line \ref{lst:af-lineref-channel} in listing \ref{lst:annotated-policy}
    for an example channel declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Channel name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="size" type="memorySizeType" use="required">
   <xs:annotation>
    <xs:documentation>
     Size of the channel in bytes. Must be a multiple of page size (4K).
     Enforced by validator.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="hasEvent" type="eventModeType" use="optional">
   <xs:annotation>
    <xs:documentation>
     Associated event type (if any).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="channelReferencesType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{channel} section of a subject declares references to
    communication channels. The referenced channels become accessible to the
    requesting subject either as reader or writer endpoint.

    See line \ref{lst:af-lineref-subj-channels} in listing
    \ref{lst:annotated-policy} for an example section.
   </xs:documentation>
  </xs:annotation>
  <xs:choice minOccurs="0" maxOccurs="unbounded">
   <xs:element name="reader" type="channelReaderType"/>
   <xs:element name="writer" type="channelWriterType"/>
  </xs:choice>
 </xs:complexType><xs:complexType name="channelReaderType">
  <xs:annotation>
   <xs:documentation>
    A channel \texttt{reader} element references a global communication channel
    as reader endpoint, i.e. the channel is mapped read-only into the subject
    address space.

    See line \ref{lst:af-lineref-subj-channels-reader} in listing
    \ref{lst:annotated-policy} for an example reader declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of reader channel.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of physical channel.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Address of mapping in subject address space.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="vector" type="vectorType" use="optional">
   <xs:annotation>
    <xs:documentation>
     Associated vector. Must be set if a physical channel with \texttt{hasEvent}
     mode \texttt{!= switch} is referenced (enforced by validator).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="channelWriterType">
  <xs:annotation>
   <xs:documentation>
    A channel \texttt{writer} element references a global communication channel
    as writer endpoint, i.e. the channel is mapped with write permissions into
    the subject address space.

    See line \ref{lst:af-lineref-subj-channels-writer} in listing
    \ref{lst:annotated-policy} for an example writer declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of writer channel.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of physical channel.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Address of mapping in subject address space.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="event" type="xs:nonNegativeInteger" use="optional">
   <xs:annotation>
    <xs:documentation>
     Associated event number. Must be set if a physical channel with
     \texttt{hasEvent} attribute is referenced.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="componentsType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{components} element holds a list of components and component
    libraries.

    Note that components are a policy source format abstraction. The toolchain
    resolves this concept into subjects by adding the appropriate memory
    regions, events and devices.

    See line \ref{lst:af-lineref-components} in listing \ref{lst:annotated-policy}
    for an example components section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="library" type="libraryType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="component" type="componentType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="componentType">
  <xs:annotation>
   <xs:documentation>
    A component is a piece of software which shall be executed by the SK.
    Components represent the building blocks of a component-based system and can
    be regarded as templates for executable entities instantiated by subjects.

    The specification of a component declares the \emph{binary program} by means
    of (file-backed memory) regions. It also specifies the component's view of
    the expected execution environment. A component may request the following
    resources from the system:

    \begin{itemize}
    \item Logical channels
    \item Logical memory regions
    \item Logical devices
    \item Logical events
    \end{itemize}

    Components are identified by name and specify a profile. The profile
    controls the settings of the virtual CPU (vCPU).

    See line \ref{lst:af-lineref-component} in listing \ref{lst:annotated-policy}
    for an example component.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="libraryType">
    <xs:attribute name="profile" type="componentProfileType" use="required">
     <xs:annotation>
      <xs:documentation>
       Component profile.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="libraryType">
  <xs:annotation>
   <xs:documentation>
    A component library is a specialized component specification which is used
    to share common resources required for library code to operate. Component
    libraries can be included by multiple components in order to share
    functionality. An example is a logging service provided by a dedicated
    component, whereas the logging client is provided as a library with a shared
    memory channel for the actual log messages.

    A component specification declares library dependencies to request the
    library resources from the system through the inclusion of the library
    specification in the \texttt{depends} section. This way components inherit
    the resources of libraries.

    On the source code level, a library is included by mechanisms provided by
    the respective programming language. Note that the component library code is
    \emph{not} shared between components but lives in the isolated execution
    environment of a subject instantiating the component (i.e. statically linked
    libraries).

    Libraries can request the same resources as ordinary components. A subject
    instantiating the component must also map the resources requested by
    libraries the component depends on.

    See line \ref{lst:af-lineref-complib} in listing \ref{lst:annotated-policy}
    for example library specifications.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="config" type="configType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="depends" type="libraryDepsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="requires" type="requiredResourcesType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="provides" type="providedResourcesType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Component/library name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="libraryDepsType">
  <xs:annotation>
   <xs:documentation>
    Components and libraries are allowed to declare dependencies to other
    libraries. All resources required by the included library are merged with
    the ones specified by the component or library. Libraries can depend on
    other libraries.

    A subject realizing this component must correctly map all component and
    library resource requirements to physical resources in order to fulfill the
    expectations.

    See line \ref{lst:af-lineref-compdeps} in listing \ref{lst:annotated-policy}
    for an example dependency section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="library" type="namedRefType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="requiredResourcesType">
  <xs:annotation>
   <xs:documentation>
    Declaration of resources a component or library requires to operate.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="vcpu" type="vcpuType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="memory" type="logicalMemoryType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="channels" type="logicalChannelsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="devices" type="logicalDevicesType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="events" type="logicalEventsType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="providedResourcesType">
  <xs:annotation>
   <xs:documentation>
    Components usually come in the form of an executable file. To this end, the
    \texttt{provides} section specifies the memory regions of the component
    binary executable with their content.

    From a security perspective, it is often desirable to provide the different
    binary section as separate memory regions with the appropriate access
    rights, i.e. only the text section is executable, rodata is not writable and
    so on.

    Memory specified in this sections are expanded to mapped physical regions
    for each subject that instantiates this component.

    Note: the Mucbinsplit tool can be used to extract these section from an ELF
    binary into separate files and automatically add the corresponding memory
    elements to the component specification.

    See line \ref{lst:af-lineref-compprov} in listing \ref{lst:annotated-policy}
    for an example \texttt{provides} section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memory" type="providedMemType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="providedMemType">
  <xs:annotation>
   <xs:documentation>
    A \texttt{memory} element in the \texttt{provides} section declares memory
    region provided by the component. Mostly used to provide (a part) of the
    component binary.

    See line \ref{lst:af-lineref-compprov-mem} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="memoryBaseType">
    <xs:attributeGroup ref="memBaseAttrs"/>
    <xs:attribute name="virtualAddress" type="word64Type" use="required">
     <xs:annotation>
      <xs:documentation>
       Virtual address in component address space.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="subjectMemoryKindType" use="optional">
     <xs:annotation>
      <xs:documentation>
       Memory type (e.g. \texttt{subject\_binary}).
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="logicalChannelsType">
  <xs:annotation>
   <xs:documentation>
    Components and libraries use the \texttt{channels} sub-section of
    \texttt{requires} to specify expected communication channels.

    See line \ref{lst:af-lineref-compreq-chan} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:choice minOccurs="0" maxOccurs="unbounded">
   <xs:element name="reader" type="logicalChannelReaderType"/>
   <xs:element name="writer" type="logicalChannelWriterType"/>
   <xs:element name="array" type="channelArrayType"/>
  </xs:choice>
 </xs:complexType><xs:complexType name="logicalMemoryType">
  <xs:annotation>
   <xs:documentation>
    In this section, components can specify expected memory mappings with given
    access rights and region size.

    See line \ref{lst:af-lineref-compreq-memarray} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:choice minOccurs="0" maxOccurs="unbounded">
    <xs:element name="memory" type="logicalMemType"/>
    <xs:element name="array" type="memoryArrayType"/>
   </xs:choice>
  </xs:sequence>
 </xs:complexType><xs:complexType name="logicalMemType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{memory} element requests a memory region with the specified
    \texttt{size} and permissions from the system. The region is expected to be
    placed at the address given via the \texttt{virtualAddress} attribute.

    See line \ref{lst:af-lineref-compreq-mem} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:attributeGroup ref="memBaseAttrs"/>
  <xs:attribute name="size" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Size of memory in bytes. Must be a multiple of page size (4K).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected address of memory mapping.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalDevicesType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{devices} sub-section of the \texttt{requires} section is used to
    specify expected devices with their associated resources.

    See line \ref{lst:af-lineref-compreq-devs} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="device" type="logicalDeviceType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="logicalDeviceType">
  <xs:annotation>
   <xs:documentation>
    A \texttt{device} element specifies an expected logical device with its
    resources. Possible resources are \texttt{irq}, \texttt{memory} and
    \texttt{ioPort}.

    See line \ref{lst:af-lineref-compreq-dev} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="irq" type="logicalIrqType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="memory" type="logicalMemType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="ioPort" type="logicalIoPortType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical device name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalIrqType">
  <xs:annotation>
   <xs:documentation>
    An \texttt{irq} element of a logical device reference requests an IRQ with
    given number from the system policy. The specified number will be injected
    when the device requires attention for the associated logical function.

    See line \ref{lst:af-lineref-compreq-dev-irq} in listing
    \ref{lst:annotated-policy} for an example IRQ reference.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="msi" type="logicalMsiIrqType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of IRQ resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="vector" type="vectorType" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected IRQ number.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalMsiIrqType">
  <xs:annotation>
   <xs:documentation>
    The presence of \texttt{msi} child elements of an \texttt{irq} device
    resource specifies that the component expects the device to be operated in
    MSI mode. The number of elements defines the expected MSI vector number
    count to be provided by the referenced device.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of MSI resource.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalIoPortType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{ioPort} element requests a device I/O port resource with given
    range \texttt{start .. end} from the system.

    See line \ref{lst:af-lineref-compreq-dev-port} in listing
    \ref{lst:annotated-policy} for an example I/O port reference.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical I/O port name.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="start" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     I/O port start address.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="end" type="word16Type" use="required">
   <xs:annotation>
    <xs:documentation>
     I/O port end address.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalChannelReaderType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{reader} element requests a read-only channel of the specified
    size, address and optional notification vector.

    See line \ref{lst:af-lineref-compreq-channel-reader} in listing
    \ref{lst:annotated-policy} for an example channel reader specification.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of reader channel.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected address of channel memory mapping.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="size" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected size of channel. Must be a multiple of page size (4K).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="vector" type="vectorType" use="optional">
   <xs:annotation>
    <xs:documentation>
     Notification vector.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalChannelWriterType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{writer} element requests a channel with write permissions of the
    specified size, address and optional notification event number.

    See line \ref{lst:af-lineref-compreq-channel-writer} in listing
    \ref{lst:annotated-policy} for an example channel writer specification.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of writer channel.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="virtualAddress" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected address of channel memory mapping.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="size" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected size of channel. Must be a multiple of page size (4K).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="event" type="xs:nonNegativeInteger" use="optional">
  <xs:annotation>
   <xs:documentation>
    Notification event number.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
</xs:complexType><xs:attributeGroup name="arrayBaseAttrs">
  <xs:attribute name="virtualAddressBase" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Expected address of memory mapping.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="elementSize" type="word64Type" use="required">
   <xs:annotation>
    <xs:documentation>
     Size of one array element in bytes. Must be a multiple of page size (4K).
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:attributeGroup><xs:complexType name="arrayEntryType">
  <xs:annotation>
   <xs:documentation>
    Array entries specify the number of array elements and assign a logical name
    to each element.

    See line \ref{lst:af-lineref-compreq-array-entry} in listing
    \ref{lst:annotated-policy} for an example array entry declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of array entry.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="memoryArrayType">
  <xs:annotation>
   <xs:documentation>
    The memory array abstraction simplifies the declaration of consecutive
    memory mappings with a given base address, region size and
    \texttt{executable} and \texttt{writable} attributes. The child elements
    declare the number of expected regions.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memory" type="arrayEntryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
  <xs:attributeGroup ref="memBaseAttrs"/>
  <xs:attributeGroup ref="arrayBaseAttrs"/>
 </xs:complexType><xs:complexType name="channelArrayType">
  <xs:annotation>
   <xs:documentation>
    The channel array abstraction simplifies the declaration of consecutive
    channel mappings with a given base address, channel size and optional
    event/vector bases. The child elements declare the number of expected
    channels and either the \texttt{reader} or \texttt{writer} role.

    See line \ref{lst:af-lineref-compreq-chanarr} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:choice>
   <xs:element name="reader" type="arrayEntryType" minOccurs="1" maxOccurs="unbounded"/>
   <xs:element name="writer" type="arrayEntryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:choice>
  <xs:attributeGroup ref="arrayBaseAttrs"/>
  <xs:attribute name="logical" type="nameType" use="required">
  <xs:annotation>
   <xs:documentation>
    Logical channel array name.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
 <xs:attribute name="eventBase" type="xs:nonNegativeInteger" use="optional">
  <xs:annotation>
   <xs:documentation>
    The \texttt{eventBase} attribute specifies the event number of the first
    element in the array. This number is incremented for all further elements
    in the array (\texttt{eventBase + 1}).

    Note that this attribute is only taken into consideration for a writer
    array.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
 <xs:attribute name="vectorBase" type="vectorType" use="optional">
  <xs:annotation>
   <xs:documentation>
    The \texttt{vectorBase} attribute specifies the vector number of the first
    element in the array. This number is incremented for all further elements
    in the array (\texttt{vectorBase + 1}).

    Note that this attribute is only taken into consideration for a reader
    array.
   </xs:documentation>
  </xs:annotation>
 </xs:attribute>
</xs:complexType><xs:complexType name="logicalEventsType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{events} sub-section of the \texttt{requires} section is used to
    specify expected events with optional event actions.

    A component can specify both source as well as target events.

    See line \ref{lst:af-lineref-compreq-evts} in listing
    \ref{lst:annotated-policy} for an example specification.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="source" type="logicalEventSourceType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="target" type="logicalEventTargetType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="logicalEventSourceType">
  <xs:annotation>
   <xs:documentation>
    Specifies expected source events.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="event" type="logicalSourceEventEntryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="logicalEventTargetType">
  <xs:annotation>
   <xs:documentation>
    Specifies expected event targets.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="event" type="logicalTargetEventEntryType" minOccurs="1" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="baseLogicalEventType">
  <xs:annotation>
   <xs:documentation>
    Logical event base.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name of event.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="logicalSourceEventEntryType">
  <xs:annotation>
   <xs:documentation>
    An entry in the component's source event list.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="baseLogicalEventType">
     <xs:group ref="sourceEventActionsGroup" minOccurs="0" maxOccurs="1"/>
     <xs:attribute name="id" type="xs:nonNegativeInteger" use="required">
      <xs:annotation>
       <xs:documentation>
        ID of source event.
       </xs:documentation>
      </xs:annotation>
     </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="logicalTargetEventEntryType">
  <xs:annotation>
   <xs:documentation>
    An entry in the component's target event list.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="baseLogicalEventType">
    <xs:group ref="targetEventActionsGroup" minOccurs="0" maxOccurs="1"/>
    <xs:attribute name="id" type="xs:nonNegativeInteger" use="optional">
     <xs:annotation>
      <xs:documentation>
       ID of target event entry.
      </xs:documentation>
     </xs:annotation>
    </xs:attribute>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:simpleType name="componentProfileType">
  <xs:annotation>
   <xs:documentation>
    The component profile defines default vCPU settings and triggers profile
    specific actions in the expander tool.
   </xs:documentation>
  </xs:annotation>
  <xs:restriction base="xs:string">
   <xs:enumeration value="native"/>
   <xs:enumeration value="vm"/>
   <xs:enumeration value="linux"/>
  </xs:restriction>
 </xs:simpleType><xs:complexType name="systemType">
  <xs:annotation>
   <xs:documentation>
    A Muen system policy specifies all hardware resources such as physical
    memory, devices, CPU time, etc and how these resources are accessed by the
    separation kernel, the subjects and devices.

    The \texttt{system} section is the top-level element in the Muen system
    policy.  It contains various sub-elements which specify all aspects of a
    concrete system.

    This is the \emph{source format} of the Muen system policy. It allows for
    abstractions, such as channels, which are broken down into their constituent
    parts by the toolchain in format A and B accordingly.

    See line \ref{lst:af-lineref-system} and following in listing
    \ref{lst:annotated-policy} on page \pageref{lst:annotated-policy} for an
    annotated system policy example.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="config" type="configType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="hardware" type="hardwareType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="platform" type="platformType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="memory" type="memRegionsType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="deviceDomains" type="deviceDomainsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="events" type="eventsType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="channels" type="channelsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="components" type="componentsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="subjects" type="subjectsType" minOccurs="1" maxOccurs="1"/>
   <xs:element name="scheduling" type="schedulingType" minOccurs="1" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="pinCtrlType">
  <xs:annotation>
   <xs:documentation>
    Configures Intel VMX pin-based VM-execution controls. These controls
    constitute a 32-bit vector that governs the handling of asynchronous events
    (for example: interrupts) while running in VMX non-root mode.

    See Intel SDM Vol. 3C, "24.6.1 Pin-Based VM-Execution Controls" for more
    details and the meaning of the different bit-fields.

    \begin{warning}
    Deviating from the settings provided by the component vCPU profile might
    result in unexpected system behavior. A system integrator changing any of
    these values must have a thorough understanding of both the runtime behavior
    of the Muen SK and the Intel VT-x/VT-d architecture. The
    \texttt{mucfgvalidate} tool checks that requirements for safe execution of
    Muen are met, i.e. invalid settings are detected and a meaningful error
    message is presented.
    \end{warning}
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="ExternalInterruptExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="VirtualNMIs" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ActivateVMXTimer" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ProcessPostedInterrupts" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="procCtrlType">
  <xs:annotation>
   <xs:documentation>
    The processor-based VM-execution controls constitute two 32-bit vectors that
    govern the handling of synchronous events, mainly those caused by the
    execution of specific instructions. These are the \emph{primary
    processor-based} VM-execution controls and the \emph{secondary
    processor-based} VM-execution controls.

    The \texttt{proc} element configures the primary processor-based
    VM-execution controls, see Intel SDM Vol. 3C, "24.6.2 Processor-Based
    VM-Execution Controls" for more details and the meaning of the different
    bit-fields.

    \begin{warning}
    Deviating from the settings provided by the component vCPU profile might
    result in unexpected system behavior. A system integrator changing any of
    these values must have a thorough understanding of both the runtime behavior
    of the Muen SK and the Intel VT-x/VT-d architecture. The
    \texttt{mucfgvalidate} tool checks that requirements for safe execution of
    Muen are met, i.e. invalid settings are detected and a meaningful error
    message is presented.
    \end{warning}
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="InterruptWindowExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UseTSCOffsetting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="HLTExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="INVLPGExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="MWAITExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="RDPMCExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="RDTSCExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="CR3LoadExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="CR3StoreExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="CR8LoadExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="CR8StoreExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UseTPRShadow" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="NMIWindowExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="MOVDRExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UnconditionalIOExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UseIOBitmaps" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="MonitorTrapFlag" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UseMSRBitmaps" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="MONITORExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PAUSEExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Activate2ndaryControls" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="proc2CtrlType">
  <xs:annotation>
   <xs:documentation>
    The processor-based VM-execution controls constitute two 32-bit vectors that
    govern the handling of synchronous events, mainly those caused by the
    execution of specific instructions. These are the \emph{primary
    processor-based} VM-execution controls and the \emph{secondary
    processor-based} VM-execution controls.

    The \texttt{proc2} element configures the secondary processor-based
    VM-execution controls, see Intel SDM Vol. 3C, "24.6.2 Processor-Based
    VM-Execution Controls" for more details and the meaning of the different
    bit-fields.

    \begin{warning}
    Deviating from the settings provided by the component vCPU profile might
    result in unexpected system behavior. A system integrator changing any of
    these values must have a thorough understanding of both the runtime behavior
    of the Muen SK and the Intel VT-x/VT-d architecture. The
    \texttt{mucfgvalidate} tool checks that requirements for safe execution of
    Muen are met, i.e. invalid settings are detected and a meaningful error
    message is presented.
    \end{warning}
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="VirtualAPICAccesses" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="EnableEPT" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="DescriptorTableExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="EnableRDTSCP" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Virtualizex2APICMode" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="EnableVPID" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="WBINVDExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UnrestrictedGuest" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="APICRegisterVirtualization" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="VirtualInterruptDelivery" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PAUSELoopExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="RDRANDExiting" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="EnableINVPCID" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="EnableVMFunctions" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="vmEntryCtrlType">
  <xs:annotation>
   <xs:documentation>
    Configures Intel VMX VM-entry controls. These controls constitute a 32-bit
    vector that governs the basic operation of VM entries.

    See Intel SDM Vol. 3C, "24.8.1 VM-Entry Controls" for more details and the
    meaning of the different bit-fields.

    \begin{warning}
    Deviating from the settings provided by the component vCPU profile might
    result in unexpected system behavior. A system integrator changing any of
    these values must have a thorough understanding of both the runtime behavior
    of the Muen SK and the Intel VT-x/VT-d architecture. The
    \texttt{mucfgvalidate} tool checks that requirements for safe execution of
    Muen are met, i.e. invalid settings are detected and a meaningful error
    message is presented.
    \end{warning}
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="LoadDebugControls" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="IA32eModeGuest" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="EntryToSMM" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="DeactiveDualMonitorTreatment" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="LoadIA32PERFGLOBALCTRL" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="LoadIA32PAT" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="LoadIA32EFER" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="vmExitCtrlType">
  <xs:annotation>
   <xs:documentation>
    Configures Intel VMX VM-exit controls. These controls constitute a 32-bit
    vector that governs the basic operation of VM exits.

    See Intel SDM Vol. 3C, "24.7.1 VM-Exit Controls" for more details and the
    meaning of the different bit-fields.

    \begin{warning}
    Deviating from the settings provided by the component vCPU profile might
    result in unexpected system behavior. A system integrator changing any of
    these values must have a thorough understanding of both the runtime behavior
    of the Muen SK and the Intel VT-x/VT-d architecture. The
    \texttt{mucfgvalidate} tool checks that requirements for safe execution of
    Muen are met, i.e. invalid settings are detected and a meaningful error
    message is presented.
    \end{warning}
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="SaveDebugControls" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="HostAddressspaceSize" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="LoadIA32PERFGLOBALCTRL" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="AckInterruptOnExit" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SaveIA32PAT" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="LoadIA32PAT" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SaveIA32EFER" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="LoadIA32EFER" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SaveVMXTimerValue" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="cr0Type">
  <xs:annotation>
   <xs:documentation>
    Allows to set initial values of the CR0 control register or bits in the CR0
    guest/host ownership mask.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="ProtectionEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="MonitorCoprocessor" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Emulation" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="TaskSwitched" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="WriteProtect" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="AlignmentMask" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Paging" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="cr4Type">
  <xs:annotation>
   <xs:documentation>
    Allows to set initial values of the CR4 control register or bits in the CR4
    guest/host ownership mask.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="Virtual8086" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ProtectedVirtualInts" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="TimeStampDisable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="DebuggingExtensions" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PageSizeExtensions" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PhysicalAddressExtension" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PageGlobalEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PerfCounterEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="OSSupportFXSAVE" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="OSSupportSIMDExceptions" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="UMInstructionPrevention" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SMXEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="FSGSBASEEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PCIDEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="XSAVEEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SMEPEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SMAPEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ProtectionKeyEnable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="exceptionType">
  <xs:annotation>
   <xs:documentation>
    Configures Intel VMX exception bitmap. The exception bitmap is a 32-bit
    field that contains one bit for each exception. When an exception occurs,
    its vector is used to select a bit in this field. If the bit is 1, the
    exception causes a VM exit. If the bit is 0, the exception is delivered
    normally through the IDT, using the descriptor corresponding to the
    exception’s vector.

    See Intel SDM Vol. 3C, "24.6.3 Exception Bitmap" for more details on the
    exception bitmap configuration.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="DivideError" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Debug" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Breakpoint" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="Overflow" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="BOUNDRangeExceeded" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="InvalidOpcode" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="DeviceNotAvailable" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="DoubleFault" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="CoprocessorSegmentOverrun" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="InvalidTSS" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SegmentNotPresent" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="StackSegmentFault" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="GeneralProtection" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="PageFault" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="x87FPUFloatingPointError" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="AlignmentCheck" type="bitValueType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="SIMDFloatingPointException" type="bitValueType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="vcpuType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{vcpu} element controls the execution behavior of the virtual CPU
    (vCPU). A default vCPU profile is selected by the component profile, but CPU
    execution settings can be customized both at component and subject level.

    See line \ref{lst:af-lineref-vcpu} in listing \ref{lst:annotated-policy}
    for an example on how to customize a vCPU profile.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="vmx" type="vmxType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="msrs" type="msrsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="registers" type="registersType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="vmxType">
  <xs:annotation>
   <xs:documentation>
    Controls Intel VMX vCPU settings.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="controls" type="controlsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="masks" type="masksType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="controlsType">
  <xs:annotation>
   <xs:documentation>
    Configures the following Intel VMX settings:
    \begin{itemize}
    \item Pin-Based VM-Execution Controls
    \item Primary Processor-Based VM-Execution Controls
    \item Secondary Processor-Based VM-Execution Controls
    \item VM-Entry Controls
    \item VM-Exit Controls
    \end{itemize}
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="pin" type="pinCtrlType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="proc" type="procCtrlType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="proc2" type="proc2CtrlType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="entry" type="vmEntryCtrlType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="exit" type="vmExitCtrlType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="masksType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{masks} element configures the Intel VMX CR0/CR4 guest/host masks
    and the guest/host exception bitmap.

    In general, bits set to 1 in a guest/host mask correspond to bits
    \emph{owned} by the host, causing a VM exit if the associated event occurs.

    Reading from host owned bits in CR0/CR4 does not result in a VM exit but the
    value of the CR0/CR4 read shadow is returned instead (see Intel SDM Vol. 3C,
    "24.6.6 Guest/Host Masks and Read Shadows for CR0 and CR4").
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="exception" type="exceptionType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="cr0" type="cr0Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="cr4" type="cr4Type" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="registersType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{registers} element specifies the initial value of
    general-purpose (GPR), CR0/CR4 and segment registers.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="gpr" type="gprType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="cr0" type="cr0Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="cr4" type="cr4Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="segments" type="segmentsType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="gprType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{gpr} element specifies the initial values of subject
    general-purpose registers (GPRs).
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="rip" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rsp" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rax" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rbx" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rcx" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rdx" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rdi" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rsi" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="rbp" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r08" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r09" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r10" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r11" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r12" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r13" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r14" type="word64Type" minOccurs="0" maxOccurs="1"/>
   <xs:element name="r15" type="word64Type" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="segmentsType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{segments} element specifies the initial values of
    subject segment registers.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="cs" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ds" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="es" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="fs" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="gs" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ss" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="tr" type="segmentType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="ldtr" type="segmentType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="physicalMemoryType">
  <xs:annotation>
   <xs:documentation>
    The hardware \texttt{memory} element specifies the available physical memory
    blocks including reserved memory regions (RMRR, see Intel VT-d Specification,
    "8.4 Reserved Memory Region Reporting Structure").

    Only memory blocks reported by the BIOS E820 map as non-\emph{reserved} must
    be configured in this section, e.g. \emph{usable} or \emph{ACPI NVS},
    \emph{ACPI data}.

    See line \ref{lst:af-lineref-hw-memory} in listing \ref{lst:annotated-policy}
    for an example memory element.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memoryBlock" type="memoryBlockType" minOccurs="0" maxOccurs="unbounded"/>
   <xs:element name="reservedMemory" type="reservedMemRegionType" minOccurs="0" maxOccurs="unbounded"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="deviceType">
  <xs:annotation>
   <xs:documentation>
    The \texttt{device} element specifies a physical device and its associated
    resources. There are three main device resource types:

    \begin{itemize}
    \item IRQ
    \item I/O port range
    \item Memory
    \end{itemize}

    The presence of a PCI element indicates whether the device is a PCI or a
    legacy device.

    Capabilities can be used to convey additional device-specific information.
    The base address of the memory mapped PCI config space is defined by the
    \texttt{pciConfigAddress} attribute.

    See line \ref{lst:af-lineref-hw-device} in listing \ref{lst:annotated-policy}
    for an example device declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="deviceBaseType">
    <xs:sequence>
     <xs:element name="reservedMemory" type="namedRefType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="pciType">
  <xs:annotation>
   <xs:documentation>
    PCI(e) devices are specified using the \texttt{pci} element.

    The element provides the following information:
    \begin{itemize}
    \item PCI device address (BDF)
    \item Identification
    \item IOMMU group information
    \end{itemize}

    The location of the PCI device in the PCI topology is specified by the Bus,
    Device, Function triplet (BDF).

    See line \ref{lst:af-lineref-hw-device-pci} in listing
    \ref{lst:annotated-policy} for an example PCI element declaration.
   </xs:documentation>
  </xs:annotation>
  <xs:complexContent>
   <xs:extension base="pciAddressType">
    <xs:sequence>
     <xs:element name="identification" type="deviceIdentificationType" minOccurs="1" maxOccurs="1"/>
     <xs:element name="iommuGroup" type="iommuGroupType" minOccurs="0" maxOccurs="1"/>
    </xs:sequence>
   </xs:extension>
  </xs:complexContent>
 </xs:complexType><xs:complexType name="cpuCoreType">
  <xs:annotation>
   <xs:documentation>
    Specification of one physical CPU core.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="apicId" type="xs:unsignedByte" use="required">
   <xs:annotation>
    <xs:documentation>
     CPU local APIC ID, see Intel SDM Vol. 3A, "10.4.6 Local APIC ID".
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="cpuId" type="xs:unsignedByte" use="optional">
   <xs:annotation>
    <xs:documentation>
     Unique CPU ID.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="hardwareType">
  <xs:annotation>
   <xs:documentation>
    Systems running the Muen SK perform static resource allocation at
    integration time. This means that all available hardware resources of a
    target machine must be defined in the system policy in order for these
    resources to be allocated to subjects.

    The \texttt{hardware} element is the top-level element of the hardware
    specification in the system policy. Information provided by a hardware
    description includes the amount of available physical memory blocks
    including reserved memory regions (RMRR), the number of physical CPU cores
    and hardware device resources.

    The Muen toolchain provides a handy tool to automate the cumbersome process
    of gathering hardware resource data from a running Linux system:
    \texttt{mugenhwcfg}\footnote{https://git.codelabs.ch/?p=muen/mugenhwcfg.git}.

    See line \ref{lst:af-lineref-hw} in listing \ref{lst:annotated-policy} for
    an example hardware section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="processor" type="processorType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="memory" type="physicalMemoryType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="devices" type="devicesType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="platformType">
  <xs:annotation>
   <xs:documentation>
    To enable an uniform view of the hardware resources across different
    physical machines from the system integrators perspective, the platform
    description layer is interposed between the hardware resource description
    and the rest of the system policy. This allows to build a Muen system for
    different physical target machines using the same system policy.

    See line \ref{lst:af-lineref-platform} in listing \ref{lst:annotated-policy}
    for an example platform section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="config" type="configType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="mappings" type="mappingsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="kernelDiagnostics" type="kernelDiagType" minOccurs="1" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="mappingsType">
  <xs:annotation>
   <xs:documentation>
    Platform device alias and class mappings section. Used to assign a stable
    name to a hardware device or to group (multiple) devices under a given name.

    See line \ref{lst:af-lineref-platform-mappings} in listing
    \ref{lst:annotated-policy} for an example platform mappings section.
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="aliases" type="aliasesType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="classes" type="devClassesType" minOccurs="0" maxOccurs="1"/>
  </xs:sequence>
 </xs:complexType><xs:complexType name="deviceDomainType">
  <xs:annotation>
   <xs:documentation>
    A device domain allows referenced devices access to the specified memory
    regions. It also provides handling for reserved memory region reporting
    (RMRR), see Intel VT-d Specification, "8.4 Reserved Memory Region Reporting
    Structure".
   </xs:documentation>
  </xs:annotation>
  <xs:sequence>
   <xs:element name="memory" type="memoryRefsType" minOccurs="0" maxOccurs="1"/>
   <xs:element name="devices" type="devsRefType" minOccurs="1" maxOccurs="1"/>
  </xs:sequence>
  <xs:attribute name="name" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Name of the device domain.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:complexType name="devRefType">
  <xs:annotation>
   <xs:documentation>
    Device domain device reference. Referenced devices gain access to memory
    regions of device domain.
   </xs:documentation>
  </xs:annotation>
  <xs:attribute name="logical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Logical name in this context.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="physical" type="nameType" use="required">
   <xs:annotation>
    <xs:documentation>
     Physical device or device alias to include in given device domain.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
  <xs:attribute name="mapReservedMemory" type="booleanType" use="optional">
   <xs:annotation>
    <xs:documentation>
     Whether to automatically map RMRR memory associated with device.
    </xs:documentation>
   </xs:annotation>
  </xs:attribute>
 </xs:complexType><xs:element name="system" type="systemType"/></xs:schema>
